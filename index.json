[{"date":"2020-06-11","permalink":"https://ohmypanda.github.io/2020-06-11/","summary":"生命周期太难了, 哭了。","tags":["Rust"],"title":"生命周期"},{"date":"2020-06-11","permalink":"https://ohmypanda.github.io/2020-06-11/","summary":"Rust 语法太难记了, 反直觉。又哭了。","tags":["Rust"],"title":"语法"},{"date":"2020-06-10","permalink":"https://ohmypanda.github.io/about/","summary":"Perl 6 is died, Long live Raku. 学习正则表达式 regexes in raku is awesome! 学习 Grammar Grammar in raku is awesome! 学习 Action Action in raku is awesome!","tags":null,"title":"关于"},{"date":"2020-06-10","permalink":"https://ohmypanda.github.io/2020-06-10/","summary":"Rust 太难了。 Rust 怎么这么难啊！ 真的太难了。 磕学家才学得会。","tags":["Rust"],"title":"Rust"},{"date":"2020-06-10","permalink":"https://ohmypanda.github.io/2020-06-11/","summary":"Rust 太难了, 哭了。","tags":["Rust"],"title":"Rust"},{"date":"2020-06-09","permalink":"https://ohmypanda.github.io/2020-06-09/","summary":"2020年夏天, 天气晴, 大兴区。","tags":["大兴"],"title":"大兴"},{"date":"2020-05-19","permalink":"https://ohmypanda.github.io/extract-ipconfig/","summary":"数据样例 下面这段文本是 IPCONFIG /ALL 命令的输出结果: Windows IP 配置 主机名 . . . . . . . . . . . . . : Win10-2020QJFDK 主 DNS 后缀 . . . . . . . . . . . : 节点类型 . . . . . . . . . . . . : 混合 IP 路由已启用 . . . . . . . . . . : 否 WINS 代理已启用 . . . . . . . . . : 否 以太网适配器 本地连接* 9: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Sangfor SSL VPN CS Support System VNIC 物理地址. . . . . . . . . . . . . : 00-FF-05-0D-13-A2 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 无线局域网适配器 WLAN: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Realtek RTL8192EU Wireless LAN 802.11n USB 2.0 Network Adapter 物理地址. . . . . . . . . . . . . : 30-B4-9E-40-FF-0C DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 无线局域网适配器 本地连接* 10: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Microsoft Wi-Fi Direct Virtual Adapter 物理地址. . . . . . . . . . . . . : 32-B4-9E-40-FF-0C DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 以太网适配器 以太网: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Realtek PCIe GBE Family Controller 物理地址. . . . . . . . . . . . . : 54-E1-AD-48-66-22 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 本地链接 IPv6 地址. . . . . . . . : fe80::4195:49da:a7ec:9e68%6(首选) IPv4 地址 . . . . . . . . . . . . : 192.168.0.68(首选) 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.0.1 DHCPv6 IAID . . . . . . . . . . . : 324329901 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-26-4E-B2-11-54-E1-AD-48-66-22 DNS 服务器 . . . . . . . . . . . : 61.128.128.68 TCPIP 上的 NetBIOS . . . . . . . : 已启用 分别提取含有\u0026quot;适配器\u0026quot;文字下面的「描述」、「物理地址」、「IP地址」、「子网掩码」、「默认网关」、「DNS 服务器」等信息。某些适配器下面可能实际没有「IP地址」、「子网掩码」、「默认网关」、「DNS 服务器」等，有就提取，没有就略过。 Grammar unit grammar IPConfig::Grammar; token TOP { \u0026lt;section\u0026gt;+ %% \\n* } token section { \u0026lt;header\u0026gt; \\n \u0026lt;config\u0026gt;+ } token header { ^^ \\N+ \\n } token config { ^^ \\s+ \\N+ $$ \\n* } Action unit class IPConfig::Action; method TOP($/) { make $/\u0026lt;section\u0026gt;».made; } method section($/) { my $configs = $/\u0026lt;config\u0026gt;».made; if $configs.elems \u0026gt; 0 { make ~$/\u0026lt;header\u0026gt; ~ $configs.join(''); } else { make Empty; } } method header($/) { make ~$/; } method config($/ is copy) { my $text = ~$/; if $text.contains(/'描述' | '物理地址' | IPv[4|6] ' ' 地址 | '子网掩码' | DNS ' ' 服务器/) { $/.make(~$/); } else { make Empty; } } 提取脚本 use lib '.'; use IPConfig::Grammar; use IPConfig::Action; my $ipconfig = IPConfig::Grammar.parsefile( \u0026quot;data/ifconfig.txt\u0026quot;, :actions(IPConfig::Action) ).made; .Str.say for @$ipconfig; 输出 以太网适配器 本地连接* 9: 描述. . . . . . . . . . . . . . . : Sangfor SSL VPN CS Support System VNIC 物理地址. . . . . . . . . . . . . : 00-FF-05-0D-13-A2 无线局域网适配器 WLAN: 描述. . . . . . . . . . . . . . . : Realtek RTL8192EU Wireless LAN 802.11n USB 2.0 Network Adapter 物理地址. . . . . . . . . . . . . : 30-B4-9E-40-FF-0C 无线局域网适配器 本地连接* 10: 描述. . . . . . . . . . . . . . . : Microsoft Wi-Fi Direct Virtual Adapter 物理地址. . . . . . . . . . . . . : 32-B4-9E-40-FF-0C 以太网适配器 以太网: 描述. . . . . . . . . . . . . . . : Realtek PCIe GBE Family Controller 物理地址. . . . . . . . . . . . . : 54-E1-AD-48-66-22 本地链接 IPv6 地址. . . . . . . . : fe80::4195:49da:a7ec:9e68%6(首选) IPv4 地址 . . . . . . . . . . . . : 192.168.0.68(首选) 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : 192.168.0.1 DNS 服务器 . . . . . . . . . . . : 61.128.128.68","tags":["Grammar"],"title":"提取 ipconfig 命令的部分输出"},{"date":"2020-05-11","permalink":"https://ohmypanda.github.io/2020-05-11/","summary":"Less Than Awesome.","tags":["Awesome"],"title":"Awesome"},{"date":"2020-05-06","permalink":"https://ohmypanda.github.io/extract-sections-with-double-percent/","summary":"数据样例 section.txt 中的本文为样例数据: 123,456,789 =begin code 999,333,666 145,123,120 =end code 10,20,30 10,10,10 =begin code 567,555,578 678,679,665 710,720,715 =end code 321,654,987 =begin code 312,555 =end code 要求把 =begin code 和 =end code 之间的所有数字分别提取出来。 Grammar Grammar 的结构如下, 其中 Section 目录下分别是 Grammar 和 Action 模块, data 目录下是样例数据 section.txt: ├── Section │ ├── Actions.pm6 │ └── Grammar.pm6 ├── data │ ├── section.txt ├── extract-section.p6 use Grammar::Debugger; use Grammar::Tracer; unit grammar Section::Grammar; token TOP { ^ \u0026lt;section\u0026gt;+ %% \u0026lt;separator\u0026gt; $ } token section { \u0026lt;line\u0026gt;+ } token line { ^^ [\\d+]+ %% ',' $$ \\n } token separator { | ^^ '=begin code' $$ \\n | ^^ '=end code' $$ \\n* } 其中 Grammar::Debugger 和 Grammar::Tracer 模块用于调试 grammar, 需要放在 grammar 模块的行首: use Grammar::Debugger; use Grammar::Tracer; Action unit class Section::Actions; method TOP($/) { make $/.values».made; } method section($/) { make ~$/.trim; } method line($/) { make ~$/.trim; } method separator($/) { make Empty; } 解析 不使用 Action use lib '.'; use Section::Grammar; my $parsed = Section::Grammar.parsefile(@*ARGS[0] // 'data/section.txt'); .Str.say for $parsed\u0026lt;section\u0026gt;; 输出 123,456,789 999,333,666 145,123,120 10,20,30 10,10,10 567,555,578 678,679,665 710,720,715 321,654,987 312,555 使用 Action use lib '.'; use Section::Grammar; use Section::Actions; my $parsed = Section::Grammar.parsefile( @*ARGS[0] // 'data/section.txt', :actions(Section::Actions) ).made; .Str.say for @$parsed; 输出 123,456,789 999,333,666 145,123,120 10,20,30 10,10,10 567,555,578 678,679,665 710,720,715 321,654,987 312,555","tags":["Grammar"],"title":"使用 %% 提取文本块儿"},{"date":"2020-05-06","permalink":"https://ohmypanda.github.io/extract-sections-again/","summary":"数据样例 Here's some unimportant text. =begin code This code block is what we're after. We'll use 'ff' to get it. =end code More unimportant text. =begin code I want this line. and this line as well. HaHa. =end code More unimport text. =begin code Let's to go home. =end code Grammar use Grammar::Debugger; use Grammar::Tracer; unit grammar Range::Grammar; token TOP { ^ \u0026lt;un-important-line\u0026gt;+ %% \u0026lt;section\u0026gt; $ } token section { \u0026lt;begin\u0026gt; ~ \u0026lt;end\u0026gt; \u0026lt;line\u0026gt;+? } token un-important-line { ^^ \\N+ )\u0026gt; \\n* } token line { ^^ \\N+ )\u0026gt; \\n* } token begin { ^^ '=begin code' $$ \\n* } token end { ^^ '=end code' $$ \\n* } Action unit class Range::Actions; method TOP($/) { make $/.values».made; } method section($/) { make $/\u0026lt;line\u0026gt;».made; } method line($/) { make ~$/.trim; } method un-important-line($/) { make Empty; } method begin($/) { make Empty; } method end($/) { make Empty; } 提取 #!/usr/bin/env perl6 use lib '.'; use Range::Grammar; use Range::Actions; my $parsed = Range::Grammar.parsefile( @*ARGS[0] // 'data/flip-flop.txt', :actions(Range::Actions) ).made; for @$parsed -\u0026gt; $line { say $line.raku; say '-' x 35; } 输出 $[\u0026quot;This code block is what we're after.\u0026quot;, \u0026quot;We'll use 'ff' to get it.\u0026quot;] ----------------------------------- $[\u0026quot;I want this line.\u0026quot;, \u0026quot;and this line as well.\u0026quot;, \u0026quot;HaHa.\u0026quot;] ----------------------------------- $[\u0026quot;Let's to go home.\u0026quot;] -----------------------------------","tags":["Grammar"],"title":"再用 %% 提取文本块儿"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/extract-sections/","summary":"数据样例 Here's some unimportant text. =begin code This code block is what we're after. We'll use 'ff' to get it. =end code More unimportant text. =begin code I want this line. and this line as well. HaHa =end code More unimport text. =begin code Let's to go home. =end code 要求提取 =begin code 和 =end code 之间的文本块儿。 Grammar grammar ExtractSection { token start { ^^ '=begin code' \\n } token finish { ^^ '=end code' \\n } token line { ^^ \\N+)\u0026gt; \\n } token section { \u0026lt;start\u0026gt; ~ \u0026lt;finish\u0026gt; \u0026lt;line\u0026gt;+? } token comment { ^^\\N+ \\n } token TOP { [\u0026lt;section\u0026gt; || \u0026lt;comment\u0026gt;]+ } } Action class ExtractSectionAction { method TOP($/) { make @\u0026lt;section\u0026gt;».ast.List } method section($/) { make ~«@\u0026lt;line\u0026gt;.List } method line($/) { make ~$/.trim } method comment($/) { make Empty } } 提取 my $em = ExtractSection.parse( $excerpt, :actions(ExtractSectionAction) ).ast; for @$em -\u0026gt; $line { say $line.perl; say '-' x 35; } 输出 $(\u0026quot;This code block is what we're after.\u0026quot;, \u0026quot;We'll use 'ff' to get it.\u0026quot;) ----------------------------------- $(\u0026quot;I want this line.\u0026quot;, \u0026quot;and this line as well.\u0026quot;, \u0026quot;HaHa\u0026quot;) ----------------------------------- $(\u0026quot;Let's to go home.\u0026quot;,) -----------------------------------","tags":["Grammar"],"title":"提取文本块儿"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/subparse/","summary":"子解析 游标不一定要到达字符串的末尾才算成功。也就是说，它不一定要匹配整个字符串。 subparse 总是返回一个 Match 对象 method subparse( $target, :$rule = 'TOP', Capture() :$args = \\(), Mu :$actions = Mu, *%opt ) Grammar grammar RepeatChar { token start($character) { $character+ } } 解析 say RepeatChar.subparse( 'bbbabb', :rule('start'), :args(\\('b')) ); # ｢bbb｣ say RepeatChar.parse( 'bbbabb', :rule('start'), :args(\\('b')) ); # Nil say RepeatChar.subparse( 'bbbabb', :rule('start'), :args(\\('a')) ); # \u0026lt;failed match\u0026gt; say RepeatChar.subparse( 'bbbabb', :rule('start'), :args(\\('a')), :pos(3) ); # ｢a｣","tags":["Grammar"],"title":"子解析"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/parse-structured-text/","summary":"数据样例 [28/04/2015 12:32] Title1 content line 1 content line 2 content line 3 content line 4 content line 5 [28/04/2015 12:16] Title2 content line 6 content line 7 [27/04/2015 17:30] ​Title3 content line 8 content line 9 content line 10 Grammar grammar StructedText { token TOP { ^ \u0026lt;entry\u0026gt;+ $ } token entry { \u0026lt;head\u0026gt; \\s* # 每一项有一个标题 \u0026lt;line\u0026gt;+ \\s* # 每个标题下面有很多行 } token head { '[' \u0026lt;datetime\u0026gt; ']' \\s+ \u0026lt;title\u0026gt; } token datetime { \u0026lt;filedate\u0026gt; \\s+ \u0026lt;filetime\u0026gt; } token filedate { [\\d+]+ % '/' } token filetime { [\\d+]+ % ':' } token title { \\N+ } token line { [ \u0026lt;!head\u0026gt; # 前面不是 head 标题 . # 点号匹配换行符 ]+ } } Action class StructedText::Actions { method line ($/) { $/.make: ~$/ } method filedate($/) { $/.make: ~$/.subst(rx/\u0026lt;[:/]\u0026gt;/, '-', :g) } method head ($/) { $/.make: ~$/.subst(rx/\u0026lt;[:/]\u0026gt;/, '-', :g) } method entry ($/) { make $\u0026lt;head\u0026gt;.ast =\u0026gt; $\u0026lt;line\u0026gt;».made; } method TOP ($/) { $/.make: $\u0026lt;entry\u0026gt;».ast; } } 解析 my $actions = StructedText::Actions.new; my $parsed = StructedText.parsefile('sample.txt', :$actions).made; if $parsed { for @$parsed -\u0026gt; $e { my $filename = ~$e.key.match(/'[' \u0026lt;( \u0026lt;-[\\[\\]]\u0026gt;+ )\u0026gt; ']'/) ~ \u0026quot;.txt\u0026quot;; my $fh = open $filename, :w; $fh.say: ~$e.key; for $e.value -\u0026gt; $v { $fh.say: $v; } $fh.close; say \u0026quot;生成文件 $filename \u0026quot;; } }","tags":["Grammar"],"title":"解析结构化文本"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/calc-lang/","summary":"数据样例 x = 40 + 2; print x; y = x - (5/2); print y; z = 1 + y * x; print z; print 14 - 16/3 + x; 目录结构如下: . ├── Lang │ ├── Actions.pm6 │ └── Grammar.pm6 ├── data │ ├── calc.lang Grammar Grammar.pm6 的内容如下: unit grammar Lang::Grammar; rule TOP { ^ \u0026lt;statements\u0026gt; $ } rule statements { \u0026lt;statement\u0026gt;+ %% ';' } rule statement { | \u0026lt;assignment\u0026gt; | \u0026lt;printout\u0026gt; } rule assignment { \u0026lt;identifier\u0026gt; '=' \u0026lt;expression\u0026gt; } rule printout { 'print' \u0026lt;expression\u0026gt; } rule expression { | \u0026lt;term\u0026gt;+ %% $\u0026lt;op\u0026gt;=(['+'|'-']) | \u0026lt;group\u0026gt; } rule term { \u0026lt;factor\u0026gt;+ %% $\u0026lt;op\u0026gt;=(['*'|'/']) } rule factor { | \u0026lt;identifier\u0026gt; | \u0026lt;value\u0026gt; | \u0026lt;group\u0026gt; } rule group { '(' \u0026lt;expression\u0026gt; ')' } token identifier { (\u0026lt;:alpha\u0026gt;+) } token value { ( | \\d+['.' \\d+]? | '.' \\d+ ) } Action Actions.pm6 的内容如下: unit class Lang::Actions; has %.var; method assignment($/) { %!var{$\u0026lt;identifier\u0026gt;} = $\u0026lt;expression\u0026gt;.ast; } method printout($/) { say $\u0026lt;expression\u0026gt;.ast; } method expression($/) { if $\u0026lt;group\u0026gt; { $/.make: $\u0026lt;group\u0026gt;.ast } else { my $result = $\u0026lt;term\u0026gt;[0].ast; if $\u0026lt;op\u0026gt; { my @ops = $\u0026lt;op\u0026gt;.map(~*); my @vals = $\u0026lt;term\u0026gt;[1..*].map(*.ast); for 0..@ops.elems - 1 -\u0026gt; $c { if @ops[$c] eq '+' { $result += @vals[$c]; } else { $result -= @vals[$c]; } } } $/.make: $result; } } method term($/) { my $result = $\u0026lt;factor\u0026gt;[0].ast; if $\u0026lt;op\u0026gt; { my @ops = $\u0026lt;op\u0026gt;.map(~*); my @vals = $\u0026lt;factor\u0026gt;[1..*].map(*.ast); for 0..@ops.elems - 1 -\u0026gt; $c { if @ops[$c] eq '*' { $result *= @vals[$c]; } else { $result /= @vals[$c]; } } } $/.make: $result; } method factor($/) { if $\u0026lt;identifier\u0026gt; { $/.make: %!var{~$\u0026lt;identifier\u0026gt;} // 0 } elsif $\u0026lt;value\u0026gt; { $/.make: $\u0026lt;value\u0026gt;.ast } elsif $\u0026lt;group\u0026gt; { $/.make: $\u0026lt;group\u0026gt;.ast } } method group($/) { $/.make: $\u0026lt;expression\u0026gt;.ast } method identifier($/) { $/.make: ~$0 } method value($/) { $/.make: +$0 } 解析 use lib '.'; use Lang::Grammar; use Lang::Actions; my $parsed = Lang::Grammar.parsefile(@*ARGS[0] // 'data/calc.lang', :actions(Lang::Actions.new())); say $parsed;","tags":["Grammar"],"title":"计算器"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/parse-json/","summary":"数据样例 { \u0026quot;country\u0026quot;: \u0026quot;Austria\u0026quot;, \u0026quot;cities\u0026quot;: [ \u0026quot;Wien\u0026quot;, \u0026quot;Salzburg\u0026quot;, \u0026quot;Innsbruck\u0026quot; ], \u0026quot;population\u0026quot;: 8353243 } Grammar grammar JSON::Tiny::Grammar { rule TOP { ^[ \u0026lt;object\u0026gt; | \u0026lt;array\u0026gt; ]$ } rule object { '{' ~ '}' \u0026lt;pairlist\u0026gt; } rule pairlist { \u0026lt;pair\u0026gt;* % [ \\, ] } rule pair { \u0026lt;string\u0026gt; ':' \u0026lt;value\u0026gt; } rule array { '[' ~ ']' [ \u0026lt;value\u0026gt;* % [ \\, ] ] } proto token value { \u0026lt;...\u0026gt; }; token value:sym\u0026lt;number\u0026gt; { '-'? [ 0 | \u0026lt;[1..9]\u0026gt; \u0026lt;[0..9]\u0026gt;* ] [ \\. \u0026lt;[0..9]\u0026gt;+ ]? [ \u0026lt;[eE]\u0026gt; [\\+|\\-]? \u0026lt;[0..9]\u0026gt;+ ]? } token value:sym\u0026lt;true\u0026gt; { \u0026lt;sym\u0026gt; }; token value:sym\u0026lt;false\u0026gt; { \u0026lt;sym\u0026gt; }; token value:sym\u0026lt;null\u0026gt; { \u0026lt;sym\u0026gt; }; token value:sym\u0026lt;object\u0026gt; { \u0026lt;object\u0026gt; }; token value:sym\u0026lt;array\u0026gt; { \u0026lt;array\u0026gt; }; token value:sym\u0026lt;string\u0026gt; { \u0026lt;string\u0026gt; } token string { \\\u0026quot; ~ \\\u0026quot; [ \u0026lt;str\u0026gt; | \\\\ \u0026lt;str_escape\u0026gt; ]* } token str { [ \u0026lt;!before \\t\u0026gt; \u0026lt;!before \\n\u0026gt; \u0026lt;!before \\\\\u0026gt; \u0026lt;!before \\\u0026quot;\u0026gt; . ]+ # \u0026lt;-[\u0026quot;\\\\\\t\\n]\u0026gt;+ } token str_escape { \u0026lt;[\u0026quot;\\\\/bfnrt]\u0026gt; | u \u0026lt;xdigit\u0026gt;**4 } } 解析 # test it: my $tester = '{ \u0026quot;country\u0026quot;: \u0026quot;Austria\u0026quot;, \u0026quot;cities\u0026quot;: [ \u0026quot;Wien\u0026quot;, \u0026quot;Salzburg\u0026quot;, \u0026quot;Innsbruck\u0026quot; ], \u0026quot;population\u0026quot;: 8353243 }'; if JSON::Tiny::Grammar.parse($tester) { say \u0026quot;It's valid JSON\u0026quot;; } else { # TODO: error reporting say \u0026quot;Not quite...\u0026quot;; }","tags":["Grammar"],"title":"解析 JSON"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/parse-csv/","summary":"数据样例 Year,Make,Model,Length 1997,Ford,E350,2.34 2000,Mercury,Cougar,2.38 Grammar grammar CSV { token TOP { [ \u0026lt;line\u0026gt; \\n? ]+ } token line { ^^ # Beginning of a line \u0026lt;value\u0026gt;* % \\, # Any number of \u0026lt;value\u0026gt;s with commas in `between` them $$ # End of a line } token value { [ | \u0026lt;-[\u0026quot;,\\n]\u0026gt; # Anything not a double quote, comma or newline | \u0026lt;quoted-text\u0026gt; # Or some quoted text ]* # Any number of times } token quoted-text { \\\u0026quot; [ | \u0026lt;-[\u0026quot;\\\\]\u0026gt; # Anything not a \u0026quot; or \\ | '\\\u0026quot;' # Or \\\u0026quot;, an escaped quotation mark ]* # Any number of times \\\u0026quot; } } 解析 say \u0026quot;Valid CSV file!\u0026quot; if CSV.parse( q:to/EOCSV/ ); Year,Make,Model,Length 1997,Ford,E350,2.34 2000,Mercury,Cougar,2.38 EOCSV","tags":["Grammar"],"title":"检测 CSV 是否有效"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/card-game-with-action/","summary":"数据样例 a♥ a♥ 7♦ 8♣ j♥ a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦ Grammar grammar CardGame { rule TOP { ^ \u0026lt;deal\u0026gt; $ } rule deal { :my %*PLAYED = (); \u0026lt;hand\u0026gt;+ % ';' } rule hand { [ \u0026lt;card\u0026gt; ]**5 } token card {\u0026lt;face\u0026gt;\u0026lt;suit\u0026gt;} proto token suit {*} token suit:sym\u0026lt;♥\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♦\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♣\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♠\u0026gt; {\u0026lt;sym\u0026gt;} token face {:i \u0026lt;[2..9]\u0026gt; | 10 | j | q | k | a } } Action class CardGame::Actions { method card($/) { my $card = $/.lc; say \u0026quot;Hey, there's an extra $card\u0026quot; if %*PLAYED{$card}++; } } 解析 my $a = CardGame::Actions.new; say CardGame.parse(\u0026quot;a♥ a♥ 7♦ 8♣ j♥\u0026quot;, :actions($a)); # \u0026quot;Hey there's an extra a♥\u0026quot; say CardGame.parse(\u0026quot;a♥ 7♥ 7♦ 8♣ j♥; 10♥ j♥ q♥ k♥ a♦\u0026quot;, :actions($a)); # \u0026quot;Hey there's an extra j♥\u0026quot;","tags":["Grammar"],"title":"解析带 Action 的纸牌游戏"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/card-game/","summary":"数据样例 2♥ 5♥ 7♦ 8♣ 9♠ 2♥ a♥ 7♦ 8♣ j♥ Grammar grammar CardGame { rule TOP { ^ \u0026lt;deal\u0026gt; $ } rule deal { \u0026lt;hand\u0026gt;+ % ';' } rule hand { [ \u0026lt;card\u0026gt; ]**5 } token card {\u0026lt;face\u0026gt;\u0026lt;suit\u0026gt;} proto token suit {*} token suit:sym\u0026lt;♥\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♦\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♣\u0026gt; {\u0026lt;sym\u0026gt;} token suit:sym\u0026lt;♠\u0026gt; {\u0026lt;sym\u0026gt;} token face {:i \u0026lt;[2..9]\u0026gt; | 10 | j | q | k | a } } 解析 say CardGame.parse(\u0026quot;2♥ 5♥ 7♦ 8♣ 9♠\u0026quot;); say CardGame.parse(\u0026quot;2♥ a♥ 7♦ 8♣ j♥\u0026quot;);","tags":["Grammar"],"title":"解析纸牌游戏"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/alaways-succeed-assertion/","summary":"数据样例 255 435 777 123 456 789 098 764 125 Grammar grammar Digifier { rule TOP { [ \u0026lt;.succ\u0026gt; \u0026lt;digit\u0026gt;+ ]+ } token succ { \u0026lt;?\u0026gt; } token digit { \u0026lt;[0..9]\u0026gt; } } Action class Devanagari { has @!numbers; method digit ($/) { @!numbers.tail ~= \u0026lt;零 一 二 三 四 五 六 七 八 九\u0026gt;[$/] } method succ ($) { @!numbers.push: '' } method TOP ($/) { make @!numbers[^(*-1)] } } 解析 say Digifier.parse('255 435 777', actions =\u0026gt; Devanagari.new).made; # OUTPUT: 二五五 四三五 七七七","tags":["Grammar"],"title":"Alaways Succeed Assertion"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/parse-university/","summary":"数据样本 [Wang, Zhiguo; Zhao, Zhiguo] Hangzhou Normal Univ, Ctr Cognit \u0026amp; Brain Disorders, Hangzhou, Zhejiang, Peoples R China; [Wang, Zhiguo; Theeuwes, Jan] Vrije Univ Amsterdam, Dept Cognit Psychol, Amsterdam, Netherlands Grammar grammar University { token TOP { ^ \u0026lt;university\u0026gt; $ } token university { [ \u0026lt;bracket\u0026gt; \u0026lt;info\u0026gt; ]+ % '; ' } token bracket { '[' \u0026lt;studentname\u0026gt; '] ' } token studentname { \u0026lt;stdname=.info\u0026gt;+ % '; ' } token info { \u0026lt;field\u0026gt;+ % ', ' } token field { \u0026lt;-[,\\]\\[;\\n]\u0026gt;+ } } grammar MyUniversity is University { token university { \u0026lt;info\u0026gt;+ % '; ' } } Action class MyUniversityAction { ... } 解析 my $parsed = University::Grammar.parse($string); for @($parsed\u0026lt;university\u0026gt;\u0026lt;info\u0026gt;) -\u0026gt; $u { say $u\u0026lt;field\u0026gt;[0]; }","tags":["Grammar"],"title":"解析校名"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/key-value-pairs/","summary":"数据样例 version=6.d backend=MoarVM disto=Rakudo Star Grammar grammar KeyValuePairs { token TOP { [\u0026lt;pair\u0026gt; \\v+]* } token pair { \u0026lt;key=.identifier\u0026gt; '=' \u0026lt;value=.identifier\u0026gt; } token identifier { \\w+ } } Action class KeyValuePairsActions { method pair ($/) { $/.make: $\u0026lt;key\u0026gt;.made =\u0026gt; $\u0026lt;value\u0026gt;.made } method identifier($/) { # subroutine `make` is the same as calling .make on $/ make ~$/ } method TOP ($match) { # can use any variable name for parameter, not just $/ $match.make: $match\u0026lt;pair\u0026gt;».made } }","tags":["Grammar"],"title":"解析键值对儿"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/math-expression/","summary":"数据样例 3 + 4 - 5 3 * 4 * 5 4 + 5 * (1 + 3) Grammar grammar MathExpression { token TOP { \u0026lt;sum\u0026gt; } rule sum { \u0026lt;product\u0026gt;+ % '+' } rule product { \u0026lt;term\u0026gt;+ % '*' } rule term { \u0026lt;number\u0026gt; | \u0026lt;group\u0026gt; } rule group { '(' \u0026lt;sum\u0026gt; ')' } token number { \\d+ } } Action class MathEvalAction { method TOP($/) { make $\u0026lt;sum\u0026gt;.made; } method sum($/) { make [+] $\u0026lt;product\u0026gt;».made; } method product($/) { make [*] $\u0026lt;term\u0026gt;».made; } method term($/) { make $/.values[0].made; } method group($/) { make $\u0026lt;sum\u0026gt;.made; } method number($/) { make $/.Int; } } 解析 my $match = MathExpression.parse( '4 + 5 * (1 + 3)', actions =\u0026gt; MathEvalAction.new, ); say $match.made; # Output: 24 say $match.raku;","tags":["Grammar"],"title":"解析数学表达式"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/parse-variable-name/","summary":"数据样例 @array %hash $sum Grammar grammar VariableNames { token variable { \u0026lt;sigil\u0026gt; \u0026lt;name\u0026gt; } token sigil { '$' | '@' | '\u0026amp;' | '%' | '::' } # [ ... ] are non-capturing groups token name { \u0026lt;identifier\u0026gt; [ '::' \u0026lt;identifier\u0026gt; ] * } # 标识符以字母开头 token identifier { \u0026lt;alpha\u0026gt; \\w+ } } 匹配 my $match = VariableNames.parse(\u0026quot;@array\u0026quot;,:rule('variable')); say $match; 继承 # we inherit from the original grammar... grammar VARIABLENAMES is VariableNames { # ... and override that parsing rule that we want to change token identifier { # char classes are \u0026lt;[ ... ]\u0026gt; in Perl 6 \u0026lt;[A..Z]\u0026gt; \u0026lt;[A..Z0..9_]\u0026gt;* } } 匹配 my $test = VARIABLENAMES.parse(\u0026quot;%A_HASH_TABLE\u0026quot;,:rule('variable')); say $test; 继承 grammar LackMoney is VariableNames { token sigil { '¢' | '@' | '\u0026amp;' | '%' | '::' } } 匹配 # 继承以后, 带¢的变量能够解析, 带$的变量解析不了了 my $money = LackMoney.parse('$i_m_not_dollor',:rule('variable')); say so $money; # false","tags":["Grammar"],"title":"解析变量名"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/pair-bracket/","summary":"数据样本 [Lue, Fan] [Lou, Man-Li] [Tian, Mijie; Zhou, Lin; Zou, Xiao; Zheng, Qiaoji; Luo, Lingling; Jiang, Na; Lin, Dunmin] Grrammar grammar PairBracket { token TOP { ^ \u0026lt;line\u0026gt;+ $ } token line { \\[ \u0026lt;student\u0026gt;+ % \u0026lt;semicolon\u0026gt; \\] \\n # 换行 \\n 是最容易被忽略的地方 } token student { \u0026lt;myname\u0026gt;+ % \u0026lt;comma\u0026gt; # 分隔符也可以是一个 subrule } token myname { \u0026lt;[A..Za..z-]\u0026gt;+ # 字符类的写法 \u0026lt;[...]\u0026gt; } token comma { ',' \\s+ # 逗号 } token semicolon { ';' \\s+ } } Action class PairBracketAction { ... } 提取数据 my $parse = Lines.parsefile('test.txt'); say $parse\u0026lt;line\u0026gt;;","tags":["Grammar"],"title":"解析括号对儿之间的数据"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/ini-parser/","summary":"INI 数据 access=user ;; more details of user below [person] name=john doe address=555 Canndy Lane Grammar grammar IniFile { token key { \\w+ } token value { \u0026lt;!before \\s\u0026gt; \u0026lt;-[\\n;]\u0026gt;+ \u0026lt;!after \\s\u0026gt; } token pair { \u0026lt;key\u0026gt; \\h* '=' \\h* \u0026lt;value\u0026gt; \\n+ } token header { '[' \u0026lt;-[ \\[ \\] \\n ]\u0026gt;+ ']' \\n+ } token comment { ';' \\N*\\n+ } token block { [\u0026lt;pair\u0026gt; | \u0026lt;comment\u0026gt;]* } token section { \u0026lt;header\u0026gt; \u0026lt;block\u0026gt; } token TOP { \u0026lt;block\u0026gt; \u0026lt;section\u0026gt;* } } Action class IniFile::Action { method key($/) { make $/.Str } method value($/) { make $/.Str } method headse($/) { make $/.Str } method pair($/) { make $\u0026lt;key\u0026gt;.made =\u0026gt; $\u0026lt;value\u0026gt;.made } method block($/) { make $\u0026lt;pair\u0026gt;.map({ .made }).hash } method section($/) { make $\u0026lt;header\u0026gt;.made =\u0026gt; $\u0026lt;block\u0026gt;.made } method TOP($/) { make { _ =\u0026gt; $\u0026lt;block\u0026gt;.made, $\u0026lt;section\u0026gt;.map: { .made }, } } } 提取信息 sub parse-ini(Str $input) { my $m = IniFile.parse( $input, :actions(IniFile::Action) ); unless $m { die \u0026quot;the input is not a valid INI file\u0026quot;; } return $m.made; } sub MAIN() { say parse-ini($example); }","tags":["Grammar"],"title":"解析 INI 文件"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/station/","summary":"天气观测数据 Name= Jan Mayen Country= NORWAY Lat= 70.9 Long= 8.7 Height= 10 Start year= 1921 End year= 2009 Obs: 1921 -4.4 -7.1 -6.8 -4.3 -0.8 2.2 4.7 5.8 2.7 -2.0 -2.1 -4.0 1922 -0.9 -1.7 -6.2 -3.7 -1.6 2.9 4.8 6.3 2.7 -0.2 -3.8 -2.6 2008 -2.8 -2.7 -4.6 -1.8 1.1 3.3 6.1 6.9 5.8 1.2 -3.5 -0.8 2009 -2.3 -5.3 -3.2 -1.6 2.0 2.9 6.7 7.2 3.8 0.6 -0.3 -1.3 Grammar grammar StationDataParser { token TOP { ^ \u0026lt;keyval\u0026gt;+ \u0026lt;observations\u0026gt; $ } token keyval { $\u0026lt;key\u0026gt;=[\u0026lt;-[=]\u0026gt;+] '=' \\h* $\u0026lt;val\u0026gt;=[\\N+] \\n } token observations { 'Obs:' \\h* \\n \u0026lt;observation\u0026gt;+ } token observation { $\u0026lt;year\u0026gt;=[\\d+] \\h* \u0026lt;temp\u0026gt;+ %% [\\h*] \\n } token temp { '-'? \\d+ \\. \\d+ } } StationData 对象 class StationData { has $.name; has $.country; has @.data; submethod BUILD(:%info (:Name($!name), :Country($!country), *%), :@!data) { } } Action class StationDataActions { method TOP($/) { make StationData.new( info =\u0026gt; $\u0026lt;keyval\u0026gt;.map(*.ast).hash, data =\u0026gt; $\u0026lt;observations\u0026gt;.ast ); } method keyval($/) { make ~$\u0026lt;key\u0026gt; =\u0026gt; ~$\u0026lt;val\u0026gt;; } method observations($/) { make $\u0026lt;observation\u0026gt;.map(*.ast).grep(*.value.none \u0026lt;= -99); } method observation($/) { make +$\u0026lt;year\u0026gt; =\u0026gt; $\u0026lt;temp\u0026gt;.map(*.Num); } } 解析 say StationDataParser.parse( q:to/EOCSV/, :actions(StationDataActions) ).ast","tags":["Grammar"],"title":"解析天气预报数据"},{"date":"2020-05-05","permalink":"https://ohmypanda.github.io/trips/","summary":"行程数据 Russia Vladivostok : 43.131621,131.923828 : 4 Ulan Ude : 51.841624,107.608101 : 2 Saint Petersburg : 59.939977,30.315785 : 10 Norway Oslo : 59.914289,10.738739 : 2 Bergen : 60.388533,5.331856 : 4 Ukraine Kiev : 50.456001,30.50384 : 3 Switzerland Wengen : 46.608265,7.922065 : 3 Bern : 46.949076,7.448151 : 1 Grammar grammar SalesExport { token TOP { ^ \u0026lt;country\u0026gt;+ $ } token country { \u0026lt;name\u0026gt; \\n \u0026lt;destination\u0026gt;+ } token destination { \\s+ \u0026lt;name\u0026gt; \\s+ ':' \\s+ \u0026lt;lat=.num\u0026gt; ',' \u0026lt;long=.num\u0026gt; \\s+ ':' \\s+ \u0026lt;sales=.integer\u0026gt; \\n } token name { \\w+ [ \\s \\w+ ]* } token num { '-'? \\d+ [\\.\\d+]? } token integer { '-'? \\d+ } } Action class SalesExport::Action { method destination($/) { make ~$\u0026lt;dname\u0026gt; =\u0026gt; [$\u0026lt;sales\u0026gt;.map(*.Num+10),$\u0026lt;lat\u0026gt;.map(*.Num+90) ] } method country($/) { make ~$\u0026lt;cname\u0026gt; =\u0026gt; $\u0026lt;destination\u0026gt;\u0026gt;\u0026gt;.made } method TOP($/) { make $\u0026lt;country\u0026gt;\u0026gt;\u0026gt;.made } } 提取信息 my $actions = SalesExport::Grammar::Actions.new; my $grammar_action = SalesExport::Grammar.parse($string, :actions($actions)).made; #say $grammar_action.Str; # 获取所有国家的名字 for @$grammar_action -\u0026gt; $p { say \u0026quot;$p.key()\u0026quot;; } say '-' x 45; # 获取所有目的地 for @$grammar_action -\u0026gt; $p { for $p.value() -\u0026gt; $d { for @$d -\u0026gt; $n { say $n.key(); } } } say '-' x 45; # 获取出售的票数 for @$grammar_action -\u0026gt; $p { print \u0026quot;$p.key()\\t\u0026quot;; for $p.value() -\u0026gt; $d { my $count; for @$d -\u0026gt; $n { $count += $n.value()[0]; } say $count; } } say '-' x 45; # 获取经度 lat for @$grammar_action -\u0026gt; $p { for $p.value() -\u0026gt; $d { for @$d -\u0026gt; $n { say $n.value()[1]; } } }","tags":["Grammar"],"title":"解析行程数据"},{"date":"0001-01-01","permalink":"https://ohmypanda.github.io/search/","summary":"","tags":null,"title":"Search Results"},{"date":"0001-01-01","permalink":"https://ohmypanda.github.io/bb/","summary":"","tags":null,"title":"一句话"}]